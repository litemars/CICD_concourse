package nl.tudelft.javaparser;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

import com.github.javaparser.JavaParser;
import com.github.javaparser.ast.Node;
import com.github.javaparser.ast.body.*;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.expr.ObjectCreationExpr;
import com.github.javaparser.ast.stmt.IfStmt;
import com.github.javaparser.ast.type.ClassOrInterfaceType;


public class Attempt {
	

	
	public static void main(String[] args) throws Exception {
/*	  String statement = "{\n return numberOfArgs; \n}";
	  Node body = JavaParser.parseBlock(statement);
	  for (Node node : body.getChildrenNodes()){
		  System.out.println(node);
		  System.out.println(node.getClass());
		  for (Node node2 : node.getChildrenNodes()){
			  System.out.println(node2);
			  System.out.println(node2.getClass());
		  }
	  }*/
	  //String statement2 = "if (hasArg){}else{}";
	  
		//String sourceFolder = "/Users/setup/Desktop/Publication/Testing-Summarization2015/eclipse/workspace/commons-cli/src/java/";
		//String file="org/apache/commons/cli1/Option.java";
		String sourceFolder = "/Users/setup/Desktop/Publication/Testing-Summarization2015/eclipse/workspace/Task1/src/";
		String file="org/magee/math/Rational.java";
		List<FieldDeclaration> attributes=null;
		Node body2 = JavaParser.parse(new File(sourceFolder+file));
		//System.out.println(body2.toString());
		attributes = detectAttributes( body2);
	  System.out.println("Number of ATTRIBUTES: "+attributes.size());
	  for(int i=0; i<attributes.size();i++){
		  System.out.println("(attribute "+(i+1)+") node: \""+attributes.get(i)+"\"");
		  System.out.println("(attribute"+(i+1)+") node class type: "+attributes.get(i).getClass().getSimpleName());
	  }
	  String attributeContent=" private String argName = \"arg\";";
	  boolean res=containsTheAttribute( attributes, attributeContent);
	  System.out.println("The attribute: \""+attributeContent+"\" is contained in the list of the executed attributes? -> "+res);
	 
	  List<ConstructorDeclaration> constructorDeclarations = getConstructorDeclarations(body2);
      // now "constructorDeclarations" is populated by the constructors of the class..
	  System.out.println("Number of constructorDeclarations: "+constructorDeclarations.size());	  
	  for(int i=0; i<constructorDeclarations.size();i++){
		  System.out.println("(constructorDeclarations"+(i+1)+")  node: \""+constructorDeclarations.get(i)+"\"");
		  System.out.println("(constructorDeclarations"+(i+1)+")  node class type: "+constructorDeclarations.get(i).getClass());
	  }
	  
	  List<MethodDeclaration> methods=detectMethods(body2);
	  System.out.println("Number of METHODS: "+methods.size());	  
	  for(int i=0; i<methods.size();i++){
		  System.out.println("(method"+(i+1)+")  node: \""+methods.get(i)+"\"");
		  System.out.println("(method"+(i+1)+")  node class type: "+methods.get(i).getClass().getSimpleName());
	  }
	  List<IfStmt> ifStmts=detectIfStmts(methods,constructorDeclarations);
	  System.out.println("Number of ifStmts: "+methods.size());	  
	  for(int i=0; i<ifStmts.size();i++){
		  System.out.println("(ifStmts"+(i+1)+")  node: \""+ifStmts.get(i)+"\"");
		  System.out.println("(ifStmts"+(i+1)+")  node class type: "+ifStmts.get(i).getClass().getSimpleName());
	  }
	  //WE ALIGN Original classContent with the classContent generated by the Java parser.
	  // Thus, we compute the id corresponding the lines in the "classContent" generated by the Java parser.
      List<Integer> listIdsParsedClassInOriginalClass = computeCorrespondingIds( body2, sourceFolder, file);
      List<String> listStringsParsedClassInOriginalClass = computeCorrespondingStringIds( body2, sourceFolder, file);
      System.out.println("listIdsParsedClassInOriginalClass.size()="+listIdsParsedClassInOriginalClass.size());
      System.out.println("listStringsParsedClassInOriginalClass="+listStringsParsedClassInOriginalClass);
      //we try to find the first and last lines of a specific "if statement"
      String ifToFind="if (hasValueSeparator())";
      List<Integer> vectorWithStartAndEndOfanIfStatement=findStartAndEndOfanIfStatement(body2, ifStmts,  ifToFind,
  			listIdsParsedClassInOriginalClass,listStringsParsedClassInOriginalClass);
     
      // useful to verufy if  the current instruction contains a method or a constructor of the class
      String currentInstruction="	public boolean equals(Object o)";
      res=containsAConstructorOrAMethod(methods, constructorDeclarations,  currentInstruction);
	  System.out.println("The method/constructor: \""+currentInstruction+"\" is contained in the list of the executed constructors/methods? -> "+res);
	}
	
	
	
	public static  boolean containsAConstructorOrAMethod(List<MethodDeclaration> methods, 
			List<ConstructorDeclaration> constructorDeclarations, String currentInstruction){
		boolean res=false;
		String currentMethodOrConstructor="";
		currentInstruction=currentInstruction.replaceAll("\\s+", "");// we remove the occurrence of more than one single space" " 
		  for(int i=0;i< methods.size();i++)
		  {
			currentMethodOrConstructor=methods.get(i).toString();
			currentMethodOrConstructor=currentMethodOrConstructor.replaceAll("\\s+", "");// we remove the occurrence of more than one single space" " 
		    if(currentMethodOrConstructor.startsWith(currentInstruction)){
		    	res=true;
		    	break;
		    }
		    else{
		    	//System.out.println("This is not a contructor:\""+currentInstruction+"\"");
		    }
		  }
		  
		  for(int i=0;i< constructorDeclarations.size();i++)
		  {
			currentMethodOrConstructor=constructorDeclarations.get(i).toString();
			currentMethodOrConstructor=currentMethodOrConstructor.replaceAll("\\s+", "");// we remove the occurrence of more than one single space" " 
		    if(currentMethodOrConstructor.startsWith(currentInstruction)){
		    	res=true;
		    	break;
		    }
		    else
		    {
		    	//System.out.println("This is not a contructor:\""+currentInstruction+"\"");
		    }
		  }
		return res;
	}
	
	public static List<ConstructorDeclaration> getConstructorDeclarations(Node body2){
		List<ConstructorDeclaration> constructorDeclarations=new ArrayList<ConstructorDeclaration>();
		  for (Node node : body2.getChildrenNodes()){
			  //System.out.println("node: "+node);
			  //System.out.println("node class type: \""+node.getClass().getSimpleName()+"\"");
			// we add the ConstructorDeclaration in the list of of constructorDeclarations..
			   if(node.getClass().getSimpleName().equals("ConstructorDeclaration")){
				   constructorDeclarations.add((ConstructorDeclaration) node);
			     }
			   else{
				   //System.out.println("#node: "+node);
				   //System.out.println("#node class type: \""+node.getClass().getSimpleName()+"\"");
			   }
			  for (Node node2 : node.getChildrenNodes()){
				  //System.out.println("node: "+node2);
				  //System.out.println("node class type: \""+node2.getClass().getSimpleName()+"\"");
					// we add the ConstructorDeclaration in the list of of constructorDeclarations..
				   if(node2.getClass().getSimpleName().equals("ConstructorDeclaration")){
					   constructorDeclarations.add((ConstructorDeclaration) node2);
					     }
				   else{
					   //System.out.println("# node: "+node);
					   //System.out.println("#node class type: \""+node.getClass().getSimpleName()+"\"");
				   }
			  }
		  }
		return constructorDeclarations;
}

public static String getCallMethodName(Node node){
	String constructorName = "";
	if (node instanceof MethodCallExpr){
		MethodCallExpr call = (MethodCallExpr) node;
		constructorName = call.getName();
		 System.out.println("Number of parameters "+call.getArgs().size());
	}
	else {
		for (Node child : node.getChildrenNodes()){
			constructorName = getCallMethodName(child);
		}
	}
	return constructorName;
}
	
	public static int findIdElementIntheVector(List<String> vect, String element){
		int pos =-1;
		String temp = "";
		  for(int i=0;i<vect.size();i++)
		   {
			  temp = vect.get(i).replaceAll("( )+", "").replaceAll("\\s+", "");
			  element=element.replaceAll("( )+", "").replaceAll("\\s+", "");
			  if(temp.contains("if")){
			  //System.out.println("vect: \""+vect.get(i)+"\"");
			  //System.out.println("element: \""+element+"\"");
			    if(temp.contains(element) || element.contains(temp) ){
				   pos=i;
				   break;
			    }
			  }
		   }
		return(pos);
	}
	
	public static List<Integer> findStartAndEndOfanIfStatement(Node body2, List<IfStmt> ifStmts, String ifToFind,
			List<Integer> listIdsParsedClassInOriginalClass,
			List<String> listStringsParsedClassInOriginalClass){
		
		 ifToFind = ifToFind.replaceAll("\\s+", "") ; 
	      IfStmt if1 =null;
	      String [] vectIf1 = null;
	      String ifFirstLine = null;
	      String classContent=body2.toString();
	      String[] vectClassContent=classContent.split("\n");
	      List<Integer> vectorWithStartAndEndOfanIfStatement=new ArrayList<Integer>();//initialization..
			int pos=-1,posInOriginalClass=-1;
			int endIf=-1;
			 int c=0;
	       for(int i=0;i<ifStmts.size();i++){   
	    	    if1=ifStmts.get(i); 
	            vectIf1 = if1.toString().split("\n");
	            ifFirstLine = vectIf1[0].replaceAll("\\s+", "");
	            
	            if(ifFirstLine.contains("//")){
	            	 c=0;
	            	while(ifFirstLine.contains("//"))
	            	{
	            		c++;
	            		ifFirstLine = vectIf1[c].replaceAll("\\s+", "");
	            	}
	            }
	            if(ifToFind.contains(ifFirstLine) || ifFirstLine.contains(ifToFind)){
	                //System.out.println("this: \""+ifFirstLine+"\"");
	            	//we try to find the startIfId and the endIfId...
	            	pos = findIdElementIntheVector(listStringsParsedClassInOriginalClass,  ifFirstLine);
	            	//System.out.println("listIdsParsedClassInOriginalClass "+listIdsParsedClassInOriginalClass.size() );
	            	posInOriginalClass = listIdsParsedClassInOriginalClass.get(pos);
	            	//System.out.println("pos if InOriginalClass: "+(posInOriginalClass+1));
	            	endIf=posInOriginalClass+vectIf1.length;
	            	//System.out.println("pos end if InOriginalClass: "+(endIf+1));
	            	vectorWithStartAndEndOfanIfStatement.add(posInOriginalClass+1);//start if in the original class
	            	vectorWithStartAndEndOfanIfStatement.add(endIf);// end if in the original class
	            }
	            else{
			    	//System.out.println("ifToFind: \""+ifToFind+"\" != \""+ifFirstLine+"\"");
			    }
	        }
	       return(vectorWithStartAndEndOfanIfStatement);
	      }
	
	public static  List<IfStmt> detectIfStmts(List<MethodDeclaration> methods,List<ConstructorDeclaration> constructorDeclarations){
		List<IfStmt> ifStmts=new ArrayList<IfStmt>();
		Node body2=null;
		
		//if contained in the constructors
		
		for(int b=0;b<constructorDeclarations.size();b++)
		{		
			body2=constructorDeclarations.get(b);
			//System.out.println(classContent);
		  for (Node node : body2.getChildrenNodes()){
			  //System.out.println("node: "+node);
			  //System.out.println("node class type: \""+node.getClass().getSimpleName()+"\"");
			// we add the FieldDeclaration in the list of attributes..
			   if(node.getClass().getSimpleName().equals("IfStmt")){
				  ifStmts.add((IfStmt) node);
			     }
			   else{
				   //System.out.println("#node: "+node);
				   //System.out.println("#node class type: \""+node.getClass().getSimpleName()+"\"");
			   }
			  for (Node node2 : node.getChildrenNodes()){
				  //System.out.println("node: "+node2);
				  //System.out.println("node class type: \""+node2.getClass().getSimpleName()+"\"");
				  // we add the FieldDeclaration in the list of attributes..
				   if(node2.getClass().getSimpleName().equals("IfStmt")){
						  ifStmts.add((IfStmt) node2);
					     }
				   else{
					   //System.out.println("#node: "+node);
					   //System.out.println("#node class type: \""+node.getClass().getSimpleName()+"\"");
				   }
			  }
		  }
		}//for b
		// if in the methods
		for(int b=0;b<methods.size();b++)
		{		
			body2=methods.get(b);
			//System.out.println(classContent);
		  for (Node node : body2.getChildrenNodes()){
			  //System.out.println("node: "+node);
			  //System.out.println("node class type: \""+node.getClass().getSimpleName()+"\"");
			// we add the FieldDeclaration in the list of attributes..
			   if(node.getClass().getSimpleName().equals("IfStmt")){
				  ifStmts.add((IfStmt) node);
			     }
			   else{
				   //System.out.println("#node: "+node);
				   //System.out.println("#node class type: \""+node.getClass().getSimpleName()+"\"");
			   }
			  for (Node node2 : node.getChildrenNodes()){
				  //System.out.println("node: "+node2);
				  //System.out.println("node class type: \""+node2.getClass().getSimpleName()+"\"");
				  // we add the FieldDeclaration in the list of attributes..
				   if(node2.getClass().getSimpleName().equals("IfStmt")){
						  ifStmts.add((IfStmt) node2);
					     }
				   else{
					   //System.out.println("#node: "+node);
					   //System.out.println("#node class type: \""+node.getClass().getSimpleName()+"\"");
				   }
			  }
		  }
		}//for b
		return ifStmts;
	}
	
	public static  List<MethodDeclaration> detectMethods(Node body2){
		List<MethodDeclaration> methods=new ArrayList<MethodDeclaration>();
		String classContent=body2.toString();
		int incrementLinesCounter=0;
		while(classContent.contains("\n")){
		     incrementLinesCounter++;
		     classContent=classContent.replaceFirst("\n", "/*"+incrementLinesCounter+"#/");
		}
		classContent=classContent.replace("#/", "*/\n");
			//System.out.println(classContent);
		  for (Node node : body2.getChildrenNodes()){
			  //System.out.println("node: "+node);
			  //System.out.println("node class type: \""+node.getClass().getSimpleName()+"\"");
			// we add the FieldDeclaration in the list of attributes..
			   if(node.getClass().getSimpleName().equals("MethodDeclaration")){
				  methods.add((MethodDeclaration) node);
			     }
			   else{
				   //System.out.println("#node: "+node);
				   //System.out.println("#node class type: \""+node.getClass().getSimpleName()+"\"");
			   }
			  for (Node node2 : node.getChildrenNodes()){
				  //System.out.println("node: "+node2);
				  //System.out.println("node class type: \""+node2.getClass().getSimpleName()+"\"");
				  // we add the FieldDeclaration in the list of attributes..
				   if(node2.getClass().getSimpleName().equals("MethodDeclaration")){
						  methods.add((MethodDeclaration) node2);
					     }
				   else{
					   //System.out.println("#node: "+node);
					   //System.out.println("#node class type: \""+node.getClass().getSimpleName()+"\"");
				   }
			  }
		  }
		return methods;
	}
	
	
	public static List<String> computeCorrespondingStringIds(Node body2,String sourceFolder, String file) throws IOException{
		String originalClassContent=readFile(sourceFolder+file);
	  	String classContent=body2.toString();
      	String classContent2="";
      	String[] vectOriginalClassContent = originalClassContent.split("\n");
    	  if(vectOriginalClassContent.length==1){
    		vectOriginalClassContent = originalClassContent.split("\r");
    	  }
      	String[] vectClassContent = classContent.split("\n");
    	  if(vectClassContent.length==1){
    		  vectClassContent = originalClassContent.split("\r");
    	  }
      	System.out.println("originalClassContent:\""+vectOriginalClassContent[0]+"\"");
      	System.out.println("classContent:\""+vectClassContent[0]+"\"");
      	int i=0,incrementPos=-1;
      	List<Integer> listIdsParsedClassInOriginalClass=new ArrayList<Integer>();
      	List<String> listStringsParsedClassInOriginalClass=new ArrayList<String>();
      		while(i<vectOriginalClassContent.length & incrementPos<vectClassContent.length){
      			vectOriginalClassContent[i]=vectOriginalClassContent[i].replaceAll("( )+", " ").replaceAll("\\s+", " ");
      			 if( !vectOriginalClassContent[i].equals(""))
      			  {
      				incrementPos++;
      				 if(incrementPos<vectClassContent.length)
      				 {
      					while(vectClassContent[incrementPos].equals("")){
      					{incrementPos++;}
      				 }

      	      			vectOriginalClassContent[i]=vectOriginalClassContent[i].replaceAll("( )+", " ").replaceAll("\\s+", " ");

      				  if(incrementPos<vectClassContent.length)
      				  {
        					vectClassContent[incrementPos]=vectClassContent[incrementPos].replaceAll("( )+", " ").replaceAll("\\s+", " ");
      					if(!(vectOriginalClassContent[i].replaceAll("( )+", "").contains(vectClassContent[incrementPos].replaceAll("( )+", "")) || vectClassContent[incrementPos].replaceAll("( )+", "").contains(vectOriginalClassContent[i].replaceAll("( )+", "")))) 
     					 {
     						 System.out.println("\""+vectClassContent[incrementPos]+"\" 1!= \""+vectOriginalClassContent[i]+"\"");
      							i++;
        						 System.out.println("\""+vectClassContent[incrementPos]+"\" 2!= \""+vectOriginalClassContent[i]+"\"");
      					 }
      					if(!(vectOriginalClassContent[i].replaceAll("( )+", "").contains(vectClassContent[incrementPos].replaceAll("( )+", "")) || vectClassContent[incrementPos].replaceAll("( )+", "").contains(vectOriginalClassContent[i].replaceAll("( )+", "")))) 
    					 {
      						if(vectOriginalClassContent[i].contains("{"))
     							{
        						 System.out.println("\""+vectClassContent[incrementPos]+"\" 3!= \""+vectOriginalClassContent[i]+"\"");
       							i++;
         						 System.out.println("\""+vectClassContent[incrementPos]+"\" 4!= \""+vectOriginalClassContent[i]+"\"");
     							}
     					 }
      					
      	      			vectOriginalClassContent[i]=vectOriginalClassContent[i].replaceAll("( )+", " ").replaceAll("\\s+", " ");
      	      			 if(!vectOriginalClassContent[i].equals(""))
      					 if(vectOriginalClassContent[i].replaceAll("( )+", "").contains(vectClassContent[incrementPos].replaceAll("( )+", "")) || vectClassContent[incrementPos].replaceAll("( )+", "").contains(vectOriginalClassContent[i].replaceAll("( )+", ""))) 
      					 {
      						 //System.out.println("vectClassContent:\""+vectClassContent[incrementPos]+"\"");
      						 System.out.println("\""+vectClassContent[incrementPos]+"\" == \""+vectOriginalClassContent[i]+"\"");
            				listIdsParsedClassInOriginalClass.add(i);
            				listStringsParsedClassInOriginalClass.add(vectClassContent[incrementPos]);
              				//System.out.println("i:"+i);
      					 }
      					 else
      					 {
      						 System.out.println("\""+vectClassContent[incrementPos]+"\" != \""+vectOriginalClassContent[i]+"\"");
      					 }
      				   }
      				 }
      			   }
      			i++;
      		}//end while

				 //System.out.println("size vectClassContent:\""+vectClassContent.length+"\"");
				 //System.out.println("size vectClassContent:\""+vectClassContent.length+"\"");
				 
				return(listStringsParsedClassInOriginalClass);
	}
	
	public static List<Integer> computeCorrespondingIds(Node body2,String sourceFolder, String file) throws IOException{
		String originalClassContent=readFile(sourceFolder+file);
	  	String classContent=body2.toString();
      	String classContent2="";
      	String[] vectOriginalClassContent = originalClassContent.split("\n");
    	  if(vectOriginalClassContent.length==1){
    		vectOriginalClassContent = originalClassContent.split("\r");
    	  }
      	String[] vectClassContent = classContent.split("\n");
    	  if(vectClassContent.length==1){
    		  vectClassContent = originalClassContent.split("\r");
    	  }
      	System.out.println("originalClassContent:\""+vectOriginalClassContent[0]+"\"");
      	System.out.println("classContent:\""+vectClassContent[0]+"\"");
      	int i=0,incrementPos=-1;
      	List<Integer> listIdsParsedClassInOriginalClass=new ArrayList<Integer>();
  		while(i<vectOriginalClassContent.length & incrementPos<vectClassContent.length){
  			vectOriginalClassContent[i]=vectOriginalClassContent[i].replaceAll("( )+", " ").replaceAll("\\s+", " ");
  			 if( !vectOriginalClassContent[i].equals(""))
  			  {
  				incrementPos++;
  				 if(incrementPos<vectClassContent.length)
  				 {
  					while(vectClassContent[incrementPos].equals("")){
  					{incrementPos++;}
  				 }

  	      			vectOriginalClassContent[i]=vectOriginalClassContent[i].replaceAll("( )+", " ").replaceAll("\\s+", " ");

  				  if(incrementPos<vectClassContent.length)
  				  {
    					vectClassContent[incrementPos]=vectClassContent[incrementPos].replaceAll("( )+", " ").replaceAll("\\s+", " ");
  					if(!(vectOriginalClassContent[i].replaceAll("( )+", "").contains(vectClassContent[incrementPos].replaceAll("( )+", "")) || vectClassContent[incrementPos].replaceAll("( )+", "").contains(vectOriginalClassContent[i].replaceAll("( )+", "")))) 
 					 {
 						 System.out.println("\""+vectClassContent[incrementPos]+"\" 1!= \""+vectOriginalClassContent[i]+"\"");
  							i++;
    						 System.out.println("\""+vectClassContent[incrementPos]+"\" 2!= \""+vectOriginalClassContent[i]+"\"");
  					 }
  					if(!(vectOriginalClassContent[i].replaceAll("( )+", "").contains(vectClassContent[incrementPos].replaceAll("( )+", "")) || vectClassContent[incrementPos].replaceAll("( )+", "").contains(vectOriginalClassContent[i].replaceAll("( )+", "")))) 
					 {
  						if(vectOriginalClassContent[i].contains("{"))
 							{
    						 System.out.println("\""+vectClassContent[incrementPos]+"\" 3!= \""+vectOriginalClassContent[i]+"\"");
   							i++;
     						 System.out.println("\""+vectClassContent[incrementPos]+"\" 4!= \""+vectOriginalClassContent[i]+"\"");
 							}
 					 }
  					
  	      			vectOriginalClassContent[i]=vectOriginalClassContent[i].replaceAll("( )+", " ").replaceAll("\\s+", " ");
  	      			 if(!vectOriginalClassContent[i].equals(""))
  					 if(vectOriginalClassContent[i].replaceAll("( )+", "").contains(vectClassContent[incrementPos].replaceAll("( )+", "")) || vectClassContent[incrementPos].replaceAll("( )+", "").contains(vectOriginalClassContent[i].replaceAll("( )+", ""))) 
  					 {
  						 //System.out.println("vectClassContent:\""+vectClassContent[incrementPos]+"\"");
  						 System.out.println("\""+vectClassContent[incrementPos]+"\" == \""+vectOriginalClassContent[i]+"\"");
        				listIdsParsedClassInOriginalClass.add(i);
          				//System.out.println("i:"+i);
  					 }
  					 else
  					 {
  						 System.out.println("\""+vectClassContent[incrementPos]+"\" != \""+vectOriginalClassContent[i]+"\"");
  					 }
  				   }
  				 }
  			   }
  			i++;
  		}//end while

				 System.out.println("size vectClassContent:\""+vectClassContent.length+"\"");
				 System.out.println("size vectClassContent:\""+vectClassContent.length+"\"");
				 
				return(listIdsParsedClassInOriginalClass);
	}
	
	public static  List<FieldDeclaration> detectAttributes(Node body2){
		List<FieldDeclaration> attributes=new ArrayList<FieldDeclaration>();
		String classContent=body2.toString();
		int incrementLinesCounter=0;
		while(classContent.contains("\n")){
		     incrementLinesCounter++;
		     classContent=classContent.replaceFirst("\n", "/*"+incrementLinesCounter+"#/");
		}
		classContent=classContent.replace("#/", "*/\n");
			//System.out.println(classContent);
		  for (Node node : body2.getChildrenNodes()){
			  //System.out.println("node: "+node);
			  //System.out.println("node class type: \""+node.getClass().getSimpleName()+"\"");
			// we add the FieldDeclaration in the list of attributes..
			   if(node.getClass().getSimpleName().equals("FieldDeclaration")){
				  attributes.add((FieldDeclaration) node);
			     }
			   else{
				   //System.out.println("#node: "+node);
				   //System.out.println("#node class type: \""+node.getClass().getSimpleName()+"\"");
			   }
			  for (Node node2 : node.getChildrenNodes()){
				  //System.out.println("node: "+node2);
				  //System.out.println("node class type: \""+node2.getClass().getSimpleName()+"\"");
				  // we add the FieldDeclaration in the list of attributes..
				   if(node2.getClass().getSimpleName().equals("FieldDeclaration")){
						  attributes.add((FieldDeclaration) node2);
					     }
				   else{
					   //System.out.println("# node: "+node);
					   //System.out.println("#node class type: \""+node.getClass().getSimpleName()+"\"");
				   }
			  }
		  }
		return attributes;
	}
	
	
	public static  boolean containsTheAttribute(List<FieldDeclaration> attributes,String attributeContent){
		boolean res=false;
		String currentAttribute="";
		attributeContent=attributeContent.replaceAll("\\s+", "");// we remove the occurrence of more than one single space" " 
		  for(int i=0;i<attributes.size();i++)
		  {
			currentAttribute=attributes.get(i).toString();
			currentAttribute=currentAttribute.replaceAll("\\s+", "");// we remove the occurrence of more than one single space" " 
		    if(currentAttribute.equals(attributeContent) || currentAttribute.equals(attributeContent)){
		    	res=true;
		    	break;
		    }
		  }
		return res;
	}

	
	public static String readFile(String nomeFile) throws IOException {
		InputStream is = null;
		InputStreamReader isr = null;

		StringBuffer sb = new StringBuffer();
		char[] buf = new char[1024];
		int len;

		try {
			is = new FileInputStream(nomeFile);
			isr = new InputStreamReader(is);

			while ((len = isr.read(buf)) > 0)
				sb.append(buf, 0, len);

			return sb.toString();
		} finally {
			if (isr != null)
				isr.close();
		}
	}
}
